# Version: Python 3.10.0

import os
import sys
import json
import csv
from matplotlib import pyplot as plt
"""
This program is a tool to analyze a given simulation_log.csv and simulation_log_meta.json
Usage: Usage: py analyzing.py [path/to]/simulation_log_[timestamp]
TODO preprocessing of csv_data converting to the correct data_types
"""

def load_data(filepath: str):
    """
    opens the provided .csv and _meta.json files and loads the data into two
     dictionary objectios for further analysis
    """
    # Get absolute path
    abs_filepath = os.path.abspath(filepath)
    base_path, base_name = os.path.split(abs_filepath)
    name, _ = os.path.splitext(base_name)
    json_path = os.path.join(base_path, f"{name}_meta.json")
    csv_path = os.path.join(base_path, f"{name}.csv")
    # load JSON-data
    meta_data = {}
    try:
        with open(json_path, 'r', encoding='utf-8') as jf:
            meta_data = json.load(jf)
    except Exception as e:
        raise FileNotFoundError(f"Fehler beim Laden von {json_path}: {e}")
    # load CSV-data
    csv_data = []
    try:
        with open(csv_path, 'r', encoding='utf-8') as cf:
            reader = csv.DictReader(cf)
            csv_data = list(reader)
    except Exception as e:
        raise FileNotFoundError(f"Fehler beim Laden von {csv_path}: {e}")

    return meta_data, csv_data

def get_car_data_map(data):
    """
    returns a dictionary-object mapping each car (via car_id) to their
     respective arrival time, departure time (-1 if the car was rejected
     because of a full queue) and the car's person_count
    """
    car_data_map = {}
    for dp in data:
        # Aufbau der car_data_struktur
        car_id = dp["car_id"]
        if dp["event_type"] == "ARRIVAL":
            car_data = {
                "arrival_time":int(dp["time"]),
                "departure_time":-1,
                "person_count":int(dp["person_count"])
            }
            car_data_map[car_id] = car_data
        elif dp["event_type"] == "DEPARTURE":
            car_data_map[car_id]["departure_time"] = int(dp["time"])
    return car_data_map

def get_car_data_statistics(car_data_map):
    """
    takes the car_data_map generated by get_car_data_map(...) and calculates 
     the total amount of people in all cars, the amount of cars that tried to
     get into the queue, the amount of cars rejected due to a full queue and
     an array with all dwell times
    """
    total_people = 0
    total_arrivals = 0
    total_rejects = 0
    dwell_times = []
    for key in car_data_map:
        value = car_data_map[key]
        total_people += value["person_count"]
        total_arrivals += 1
        if value["departure_time"] == -1:
            total_rejects += 1
        else:
            dwell_times.append(value["departure_time"]-value["arrival_time"])
    return total_arrivals, total_rejects, total_people, dwell_times

def plot_dwell_time_distribution(dwell_times):
    """
    takes an integer array and plots the values in a histogram
    """
    plt.figure(figsize=(10, 6))
    plt.hist(dwell_times, bins=30, color='skyblue', edgecolor='black')
    plt.title("Dwell time distribution")
    plt.xlabel("Dwell Time (seconds)")
    plt.ylabel("Frequency")
    plt.grid(True, linestyle='--', alpha=0.6)
    plt.tight_layout()
    plt.show()

def get_cars_over_time_data(csv_data,step=300):
    """
    takes the csv-data provided by load_data(...) and calculates the amount of cars
     in the system in 5 minute intervals
    TODO optimize finding the highest value below current_time
    """
    max_time = int(csv_data[-1]["time"])
    current_time = 300   # starting value
    current_index = 0
    cars_in_system = [(0,0)] # At time 0 the amount of cars is 0

    # Find the biggest smaller than current_time
    # TODO Code not optimal, all values up to the biggest lower
    #       than current_time will be considered
    #       -> O(n*(max_time/300)) instead of O(n)
    while current_time <= max_time:
        current_amount = int(csv_data[0]["cars_in_sys"])
        for i in range(len(csv_data)):
            if int(csv_data[i]["time"]) > current_time:
                break
            current_amount = int(csv_data[i]["cars_in_sys"])
        cars_in_system.append((current_time,current_amount))
        current_time += 300
    cars_in_system.append((current_time,int(csv_data[-1]["cars_in_sys"])))
    return cars_in_system

def plot_cars_in_system_over_time(csv_data):
    """
    takes the csv-data provided by load_data(...) and plots a histogram of all cars
    in the system in 5 minute intervals
    """
    # Prepare data for plotting
    cars_in_system = get_cars_over_time_data(csv_data)
    time_points = [x[0]//60 for x in cars_in_system]
    cars_in_sys_values = [x[1] for x in cars_in_system]
    # plot data
    plt.bar(time_points, cars_in_sys_values, width=5,edgecolor='black')  # width anpassen je nach Abstand
    plt.xlabel("time (minutes)")
    plt.ylabel("cars in system")
    plt.title("cars in system over time")
    plt.grid(axis='y')
    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: py analyzing.py [path/to]/simulation_log_[timestamp]")
        sys.exit(1)
    filepath = sys.argv[1]
    try:
        # Data analysis
        meta_data, csv_data = load_data(filepath)
        car_data_map = get_car_data_map(csv_data)
        arrivals, rejects, people, dwell_times = get_car_data_statistics(car_data_map)
        # Data printout and visualization
        print(f"Queue Size {meta_data['queue_limit']}")
        print(f"Arrivals: {arrivals}, Rejects: {rejects}, Rejects %: {round((rejects*100.0)/arrivals,2)}%")
        print(f"Average People per car: {round((people*1.0)/arrivals)}")
        plot_dwell_time_distribution(dwell_times)
        plot_cars_in_system_over_time(csv_data)

    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)
